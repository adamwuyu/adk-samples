"""Tools for managing session state in the sequential orchestrator."""

import typing
from google.adk.tools import ToolContext
import logging

logger = logging.getLogger(__name__)

# 定义常量以便复用
INITIAL_MATERIAL_KEY = "initial_material"
INITIAL_REQUIREMENTS_KEY = "initial_requirements"
INITIAL_SCORING_CRITERIA_KEY = "initial_scoring_criteria"
# --- V0.5 State Keys ---
CURRENT_DRAFT_KEY = "current_draft"
CURRENT_SCORE_KEY = "current_score"
CURRENT_FEEDBACK_KEY = "current_feedback"
# --- End V0.5 State Keys ---

# V0.5 - 新增阈值 Key
SCORE_THRESHOLD_KEY = "score_threshold" # 用于判断是否提前终止循环
LOOP_CONTROL_KEY = "loop_control" # 新增：用于存放循环控制信号 ('STOP' 或 'CONTINUE')

def check_initial_data(tool_context: ToolContext) -> dict[str, str]:
    """Checks if initial_material, initial_requirements, and initial_scoring_criteria are present in the session state.

    Args:
        tool_context: The ADK tool context providing access to session state.

    Returns:
        A dict with 'status': 'ready' if all required keys are present and non-empty,
        'missing_data' otherwise.
    """
    logger.info("Checking for initial data in session state...")
    state = tool_context.state
    material = state.get(INITIAL_MATERIAL_KEY)
    requirements = state.get(INITIAL_REQUIREMENTS_KEY)
    criteria = state.get(INITIAL_SCORING_CRITERIA_KEY)

    if material and requirements and criteria:
        logger.info("Initial data found in session state.")
        return {"status": "ready"}
    else:
        missing_keys = []
        if not material: missing_keys.append(INITIAL_MATERIAL_KEY)
        if not requirements: missing_keys.append(INITIAL_REQUIREMENTS_KEY)
        if not criteria: missing_keys.append(INITIAL_SCORING_CRITERIA_KEY)
        logger.warning(f"Initial data missing in session state. Missing keys: {missing_keys}")
        return {"status": "missing_data"}

def store_initial_data(
    initial_material: str,
    initial_requirements: str,
    initial_scoring_criteria: str,
    tool_context: ToolContext
) -> dict[str, str]:
    """Stores the necessary initial data provided by the user into the session state.

    Args:
        initial_material: The initial material for writing.
        initial_requirements: The requirements for the writing task.
        initial_scoring_criteria: The criteria for scoring the draft.
        tool_context: The ADK tool context, used to access session state.

    Returns:
        A dict with a status message.
    """
    try:
        logger.info(f"Storing initial data into session state: Material='{initial_material[:50]}...', Requirements='{initial_requirements[:50]}...', Criteria='{initial_scoring_criteria[:50]}...'" )
        tool_context.state.update({
            INITIAL_MATERIAL_KEY: initial_material,
            INITIAL_REQUIREMENTS_KEY: initial_requirements,
            INITIAL_SCORING_CRITERIA_KEY: initial_scoring_criteria,
        })
        logger.info("Successfully updated session state with initial data.")
        return {"status": "Initial data successfully stored in session state."}
    except Exception as e:
        logger.error(f"Error storing initial data in session state: {e}", exc_info=True)
        return {"status": f"Failed to store initial data due to an error: {e}"}

def save_draft(draft: str, tool_context: ToolContext) -> dict[str, str]:
    """Saves the provided draft text into the session state under the 'current_draft' key.

    Args:
        draft (str): The draft text generated by the writing agent.
        tool_context: The ADK tool context providing access to session state.

    Returns:
        A dict with a status message.
    """
    try:
        logger.info(f"Saving draft to session state: '{draft[:100]}...'" )
        tool_context.state[CURRENT_DRAFT_KEY] = draft
        logger.info(f"Successfully saved draft to state key '{CURRENT_DRAFT_KEY}'.")
        return {"status": "Draft successfully saved to session state."}
    except Exception as e:
        logger.error(f"Error saving draft to session state: {e}", exc_info=True)
        return {"status": f"Failed to save draft due to an error: {e}"}

# --- 新增：获取最终草稿的 Tool ---
def get_final_draft(tool_context: ToolContext) -> dict[str, str]:
    """Retrieves the final draft text stored in the session state under the 'current_draft' key.

    Args:
        tool_context: The ADK tool context providing access to session state.

    Returns:
        A dict containing the retrieved draft text, e.g., {'final_draft_text': '...'}.
        If the draft is not found, returns a default message in the text field.
    """
    try:
        logger.info(f"Retrieving final draft from state key '{CURRENT_DRAFT_KEY}'.")
        draft_content = tool_context.state.get(CURRENT_DRAFT_KEY, "Error: Final draft not found in session state.")
        logger.info(f"Retrieved draft: '{draft_content[:100]}...'" )
        return {"final_draft_text": draft_content}
    except Exception as e:
        logger.error(f"Error retrieving final draft from session state: {e}", exc_info=True)
        return {"final_draft_text": f"Error retrieving draft: {e}"}

# --- V0.5: Tool for checking score threshold (Modified to write state) --- 
def check_score_threshold_tool(tool_context: ToolContext) -> dict:
    """Checks if the current score meets or exceeds the threshold and writes control signal to state.

    Reads CURRENT_SCORE_KEY and SCORE_THRESHOLD_KEY from session state.
    Writes 'STOP' or 'CONTINUE' to LOOP_CONTROL_KEY in session state.

    Args:
        tool_context: The ADK tool context providing access to session state.

    Returns:
        A dictionary indicating the outcome for logging purposes.
    """
    state = tool_context.state
    score = state.get(CURRENT_SCORE_KEY)
    threshold = state.get(SCORE_THRESHOLD_KEY)
    control_signal = 'CONTINUE' # Default to continue

    logger.info(f"Checking score threshold: Score={score}, Threshold={threshold}")

    if score is None or threshold is None:
        logger.warning(
            f"Cannot check score threshold: Score ('{CURRENT_SCORE_KEY}': {score}) or "
            f"Threshold ('{SCORE_THRESHOLD_KEY}': {threshold}) not found or is None in state. Setting control to CONTINUE."
        )
        control_signal = 'CONTINUE'
    else:
        try:
            score = float(score)
            threshold = float(threshold)
            if score >= threshold:
                logger.info(f"Score ({score}) meets or exceeds threshold ({threshold}). Setting control to STOP.")
                control_signal = 'STOP'
            else:
                logger.info(f"Score ({score}) is below threshold ({threshold}). Setting control to CONTINUE.")
                control_signal = 'CONTINUE'
        except (ValueError, TypeError) as e:
            logger.error(
                f"Error converting score/threshold to float: Score={score}, Threshold={threshold}. Error: {e}. Setting control to CONTINUE."
            )
            control_signal = 'CONTINUE'

    # Write the control signal to state
    state[LOOP_CONTROL_KEY] = control_signal
    logger.info(f"Wrote control signal to state: {LOOP_CONTROL_KEY}={control_signal}")

    # Return a status dictionary (Tool should return something)
    return {"status": "checked", "loop_control_set_to": control_signal} 